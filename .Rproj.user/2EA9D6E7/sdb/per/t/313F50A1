{
    "collab_server" : "",
    "contents" : "## All code required for coherence\n\n# x - dataset 1\n# y - dataset 2\n# xySectioned - data has already been blocked and treated.\n### - x and y need to be the same length right now... otherwise this will not work.\n# freqOffset - +/- freqOffset will be used to calc coherency\n# slideFreq - how far to slide (in frequency) for each calculation\n# slideIdx - how many frequency bins to move over to the next offset\n## - set to 0 with to use W as the sliding amount\n## - ignored if slideFreq is not NULL\n# blockSize - how large the blocks should be\n# offset for adjacent blocks (proportion = 0 < offset < 1)\n# adaptive - whether to use adaptive weighting or not\n# jackknife - use jackknife for variance estimates\n# prewhiten - Prewhiten the blocks\n# removePeriodic - removes line components (frequency domain approach)\n# sigCutoff - what level of F-test to ues as the cutoff in the periodic removal\n# nodes - how many cores for cluster use should this have\n# clusterType - SOCK will be local, MPI would be for HPCVL\n\n#' Calculates Frequency Domain Coherence\n#' \n#' Estimates and returns the Loeve spectrum given series x and y.\n#' \n#' @param x A \\code{vector} of values for the first dataset.\n#' @param y A \\code{vector} of values for the second dataset - if null, assumes ... \n#' I'm not sure actually.\n#' \n#' @return Returns a matrix containing the coherency.\n#' \n#' @export\ncoherency.mtm <- function(x, y = NULL, xySectioned = FALSE, n = NULL, forwardCoh = TRUE\n                          , freqRange = NULL, freqOffset = NULL, slideFreq = NULL, slideIdx = 1\n                          , nw = NULL, k = NULL, deltat = 1, nFFT = NULL, nFFT.add = 3\n                          , blockSize = NULL, overlap = NULL\n                          , adaptive = TRUE, jackknife = FALSE, prewhiten = FALSE\n                          , removePeriodic = TRUE, sigCutoff = NULL\n                          , nodes = 1, clusterType = c(\"SOCK\", \"MPI\")){\n  ## Basic Setup ##\n  \n  if (!xySectioned){\n    # not sure quite how different lengths will affect things\n    nx <- length(x)\n    ny <- length(y)\n    \n    # remove means, just in case.\n    x <- x - mean(x)\n    y <- y - mean(y)\n  } else {\n    blockSize <- length(x[[1]][[1]])\n    if (is.null(n)){stop(\"Set n when xySectioned is TRUE.\")}\n    nx <- n\n  }\n  \n  if (is.null(blockSize)){\n    blockSize <- min(nx, ny)\n  }\n  \n  if (is.null(nw)){\n    nw <- 4\n  }\n  if (is.null(k)){\n    k <- 7\n  }\n  if (is.null(nFFT)){\n    nFFT <- 2^(floor(log2(blockSize)) + nFFT.add)\n  }\n  \n  # how many indices to slide at each step.\n  if (!is.null(slideFreq)){\n    slideIdx <- round(slideFreq * deltat * nFFT)\n  } else if (is.null(slideFreq) && slideIdx == 0){\n    slideIdx <- floor((nw / (max(nx, ny) * deltat)) * (deltat * nFFT))\n  }\n  \n  ## Calculate the Slepians and lambda's ##\n  dpssIn <- dpss(n = blockSize, nw = nw, k = k)\n  slep <- dpssIn$v\n  ev <- dpssIn$eigen\n  \n  if (removePeriodic){\n    Vk <- mvfft(rbind(slep, matrix(0, ncol = k, nrow = nFFT - blockSize)))\n  }\n  \n  ## Don't need this right now, maybe in the future? Different blocksizes for each series? ... \n  # tmpY <- dpss(ny, nw = nw, k = k)\n  # slepY <- tmpY$v\n  # evY <- tmpY$eigen\n  \n  ## Sanity checks ##\n  # Warns the user if linecomponents should be removed, but no F-test significance cutoff provided.\n  if (removePeriodic && is.null(sigCutoff)){\n    warning(\"Remove periodic components requested but no cutoff significance.  Set to (1 - 1/N).\")\n    sigCutoff <- 1 - 1/(min(c(length(x), length(y))))\n  }\n  \n  # No frequency range means just a \"simple\" coherence at zero offset between x and y.\n  if (is.null(freqRange)){\n    cross <- crossSpectrum(x, y, slepX = slep, evX = ev, slepY = slep, evY = ev\n                           , nFFT = nFFT, nw = nw, k = k, nFFT.add = nFFT.add\n                           , adaptiveWeights = adaptive\n                           , removePeriodic = removePeriodic, sigCutoff = sigCutoff\n                           , returnInternals = TRUE)\n    \n    return(cross$Sxy / sqrt(cross$Sx * cross$Sy))\n  }\n  \n  ## Setup Frequency Domain Indexing ##\n  freq <- seq(0, 1/(2*deltat), by = 1/(deltat*nFFT))\n  \n  freqIdxStart <- head(which(freq >= freqRange[1]), 1)\n  freqIdxEnd <- tail(which(freq <= freqRange[2]), 1)\n  freqRangeIdx <- freqIdxStart:freqIdxEnd\n  \n  # number of indices to offset by\n  numOffsetIdx <- floor(freqOffset * deltat * nFFT)\n  if (slideIdx == 0){\n    slideTmp <- 0\n  } else {\n    slideTmp <- c(rev(seq(-slideIdx, -numOffsetIdx, by = -slideIdx)), 0, seq(slideIdx, numOffsetIdx, by = slideIdx))\n  }\n\n  if (freqIdxStart - numOffsetIdx < 1 || freqIdxEnd + numOffsetIdx > (nFFT/2+1)){\n    stop(\"Check freqRange and freqOffset - not enough frequency bins to make this combination work.\")\n  }\n  \n  ## Setup Time Domain Indexing ##\n  incr <- ceiling(blockSize * (1-overlap))\n  sectInd <- seq(1, nx-blockSize+1, by=incr)\n  numSect <- length(sectInd)\n  \n  # create a list of vectors of indices - each element of the list contains the indices of the \n  ## block that will be used\n  blockIdxLst <- as.list(as.data.frame(mapply(\":\", sectInd, sectInd+blockSize-1)))\n  \n  # might already be sectioned, probably not though...\n  if (xySectioned){\n    dat <- list()\n    for (i in 1:length(x[[1]])){\n      dat[[i]] <- list(x = x[[1]][[i]], y = x[[2]][[i]])\n    }\n  } else {\n    # create a list of the data to use for parrallel\n    dat <- list()\n    for (i in 1:length(blockIdxLst)){\n      dat[[i]] <- list(x = x[blockIdxLst[[i]]], y = y[blockIdxLst[[i]]])\n    }\n  }\n  \n  range2Start <- freqIdxStart + slideTmp\n  range2End <- range2Start + length(freqRangeIdx) - 1\n  # yIdxRange <- as.list(as.data.frame(mapply(\":\", range2Start, range2End))) # remove this - use C++ code...\n  \n  if (nodes <= 1){\n    ## do something here - no parallelization required\n    cohere <- list()\n    for (i in 1:length(blockIdxLst)){\n      cohere[[i]] <- coherencyHelper(dat[[i]], dpssIn = dpssIn, nw = nw, k = k, nFFT = nFFT\n                                     , freqRangeIdx = freqRangeIdx, range2Start = range2Start\n                                     , forwardCoh = forwardCoh\n                                     , prewhiten = prewhiten, adaptive = adaptive\n                                     , removePeriodic = removePeriodic, sigCutoff = sigCutoff\n                                     , Vk = Vk)\n    }\n  } else {\n    if (clusterType == \"SOCK\"){\n      cl <- snow::makeCluster(rep(\"localhost\", nodes), type = \"SOCK\")\n      snow::clusterSetupRNG(cl)\n      cohere <- snow::clusterApply(cl, dat, coherencyHelper\n                                   , dpssIn = dpssIn, nw = nw, k = k, nFFT = nFFT\n                                   , freqRangeIdx = freqRangeIdx, range2Start = range2Start\n                                   , forwardCoh = forwardCoh\n                                   , prewhiten = prewhiten, adaptive = adaptive,\n                                   , removePeriodic = removePeriodic, sigCutoff = sigCutoff\n                                   , Vk = Vk)\n      snow::stopCluster(cl)\n    } else if (clusterType == \"MPI\"){\n      \n    }\n  }\n  \n  # msc <- matrix(0, nrow = dim(cohere[[1]])[1], ncol = dim(cohere[[1]])[2])\n  # for (i in 1:length(cohere)){\n  #   msc = msc + abs(cohere[[i]])^2\n  # }\n  # \n  # msc2 <- apply(msc, 1, mean)\n  \n  list(coherency = cohere, forwardCoh = forwardCoh\n       , freqRange = freqRange, freqRangeIdx = freqRangeIdx, freqOffset = freqOffset\n       , freqOffsetIdx = numOffsetIdx, slideFreq = slideFreq, slideIdx = slideIdx\n       , nw = nw, k = k, deltat = deltat, nFFT = nFFT, nFFT.add = nFFT.add\n       , blockSize = blockSize, overlap = overlap\n       , adaptive = adaptive, jackknife = jackknife, prewhiten = prewhiten\n       , removePeriodic = removePeriodic, sigCutoff = sigCutoff)\n}\n\ncoherencyHelper <- function(datLst, dpssIn, nw, k, nFFT, freqRangeIdx, range2Start\n                            , forwardCoh\n                            , prewhiten, adaptive, removePeriodic, sigCutoff, Vk){\n  n <- length(datLst$x)\n  \n  if (removePeriodic){\n    yk.x <- removeLineCoh(spec.mtm(datLst$x, nw = nw, k = k, nFFT = nFFT, Ftest = TRUE, plot = FALSE\n                                   , dpssIn = dpssIn, returnInternals = TRUE)\n                   , sigCutoff = sigCutoff, Vk = Vk, k = k, nFFT = nFFT)\n    yk.y <- removeLineCoh(spec.mtm(datLst$y, nw = nw, k = k, nFFT = nFFT, Ftest = TRUE, plot = FALSE\n                                    , dpssIn = dpssIn, returnInternals = TRUE)\n                           , sigCutoff = sigCutoff, Vk = Vk, k = k, nFFT = nFFT)\n  } else {\n    yk.x <- spec.mtm(datLst$x, nw = nw, k = k, nFFT = nFFT, Ftest = TRUE, plot = FALSE\n                     , dpssIn = dpssIn, returnInternals = TRUE)$mtm$eigenCoefs\n    yk.y <- spec.mtm(datLst$y, nw = nw, k = k, nFFT = nFFT, Ftest = TRUE, plot = FALSE\n                     , dpssIn = dpssIn, returnInternals = TRUE)$mtm$eigenCoefs\n  }\n  \n  if (prewhiten){\n    # implement this... for god's sakes man!\n  }\n  \n  if (adaptive){\n    dx <- adaptiveWeightsCpp(eigenSpec = abs(yk.x)^2, ev = dpssIn$eigen, k = k, nFFT = nFFT)\n    dy <- adaptiveWeightsCpp(eigenSpec = abs(yk.y)^2, ev = dpssIn$eigen, k = k, nFFT = nFFT)\n  }\n  \n  coherencyOffsetCpp(ykx = yk.x, yky = yk.y, dx = dx, dy = dy, nTaper = k\n                     , nFreqRange = length(freqRangeIdx), nOffset = length(range2Start)\n                     , range2Start = range2Start, freqRangeIdx = freqRangeIdx\n                     , forwardCoh = forwardCoh)\n  \n}\n\n# Don't think I need this - .coherency helper will do this..\n# .crossSpectrum <- function(x, y, slep, ev, nFFT, nw, k, adaptive = TRUE){\n#   \n# }\n\nremoveLineCoh <- function(spec, sigCutoff, Vk, k, nFFT){\n  fSigIdx <- findLocalFMax(spec, cutoff = sigCutoff)\n  infl <- matrix(0, nrow = nFFT/2+1, ncol = k)\n  \n  if (length(fSigIdx) > 0){\n    for (i in 1:k){\n      for (j in 1:length(fSigIdx)){\n        # store the \n        ### Conjugate this because I need to use the correct side of the tapered data\n        infl[, i] <- infl[, i] + shift(spec$mtm$cmv[fSigIdx[j]] * Vk[, i], -fSigIdx[j]+1)[1:(nFFT/2+1)]\n      }\n    }\n  }\n  \n  eigencoef <- matrix(0, nrow = nFFT/2+1, ncol = k)\n  for (i in 1:k){\n    eigencoef[, i] <- spec$mtm$eigenCoefs[, i] - infl[, i]\n  }\n  \n  eigencoef\n}\n\n# cohLst : result from coherency.mtm()\n### /// fix this, should be for a specific offset.. silly David.\ncohPhaseByFreq <- function(coh, offsetIdx){\n  phse <- matrix(0, ncol = dim(coh$coherency[[1]])[2], nrow = length(offsetIdx))\n  \n  for (i in 1:length(coh$coherency)){\n    phse = phse + atan2(Im(coh$coherency[[i]][offsetIdx, ]), Re(coh$coherency[[i]][offsetIdx, ]))\n  }\n  \n  phse <- phse / length(coh$coherency)\n}\n\nmscFromCoh <- function(coh, jackknife = FALSE){\n  msc <- rep(0, dim(coh$coherency[[1]])[1])\n  jkVar <- rep(NA, length(msc))\n    \n  for (i in 1:length(coh$coherency)){\n    msc <- msc + apply(abs(coh$coherency[[i]])^2, 1, mean)\n  }\n  \n  if (jackknife){\n    jkloo <- matrix(0, nrow = dim(coh$coherency[[1]])[1], ncol = dim(coh$coherency[[1]])[2])\n    for (i in 1:dim(coh$coherency[[1]])[2]){\n      jkloo[, i] <- apply(abs(coh$coherency[[1]][, -i])^2, 1, mean)\n    }\n    \n    jkSlashDot <- apply(jkloo, 1, mean)\n    jkVar <- (dim(jkloo)[2] - 1) * apply(matrix(mapply(\"-\", jkloo, jkSlashDot)^2, ncol = dim(jkloo)[2])\n                   , 1, mean)\n  }\n  \n  list(msc = msc / length(coh$coherency), jkVar = jkVar)\n}\n\n\n\nfreqOffsetAxis <- function(nFFT, freqOffset, deltat){\n  c(rev(seq(0, -freqOffset, by = -1/(deltat * nFFT))), seq(0, freqOffset, by = 1/(deltat*nFFT))[-1])\n}\n\noffsetIdxFromFreq <- function(f, deltat, nFFT){\n  f * deltat * nFFT\n}\n",
    "created" : 1486954944267.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "492089236",
    "id" : "313F50A1",
    "lastKnownWriteTime" : 1487108364,
    "last_content_update" : 1487108364634,
    "path" : "~/school_lab/bin/transfer/R/coherence.R",
    "project_path" : "R/coherence.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}