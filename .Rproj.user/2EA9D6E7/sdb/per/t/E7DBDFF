{
    "collab_server" : "",
    "contents" : "#include <Rcpp.h>\n// #include <RcppArmadillo.h>\nusing namespace Rcpp;\n\n//' @title Calculate Multitaper Adaptive Weights\n//' \n//' @description Used to calculate the adaptive weights on eigenspectra using a bound on the \n//' broadband bias.\n//' \n//' @param eigenSpec A \\code{matrix} with columns containing the eigenspectra\n//' @param ev A \\code{vector} with the eigenvalues of the Slepian tapers.\n//' @param k A \\code{numeric} integer representing the number of tapers to use.\n//' @param nFFT A \\code{numeric} integer representing the total number of frequency bins \n//' that were used to estimate the spectra.\n//' \n//' @details When estimating the variance, this function will overestimate because \n//' it includes the zero and nyquist frequency twice (should only be once).\n//' \n//' @return A \\code{matrix} containing the weights for each eigenspectra at each \n//' frequency.\n// [[Rcpp::export]]\nNumericMatrix adaptiveWeightsCpp(NumericMatrix eigenSpec, NumericVector ev, int k, int nFFT) {\n  int nfreq = nFFT/2 + 1;\n  NumericVector sHat2(nfreq); // nfreq = nFFT/2 + 1\n  NumericVector sHat(nfreq);\n  NumericVector B(k); // broadband bias\n  double sigmasq = 0.0; // variance\n  double ssd; // sum of squared weights\n  NumericMatrix d(nfreq, k); // weight matrix\n  \n  // pilot spectrum and initial variance estimate\n  for (int i = 0; i < nfreq; i++){\n    sHat2[i] = 0.5 * (eigenSpec(i, 0) + eigenSpec(i, 1));\n    sigmasq += 2.0*sHat2[i];\n  }\n  \n  sigmasq = sigmasq / nFFT; // normalize the variance properly\n  \n  sHat = 2.0 * sHat2; // Rcpp sugar... vectorization\n  \n  while(mean(abs(sHat2 - sHat) / sHat) > 0.0001){\n    for (int m = 0; m < nfreq; m++){\n      sHat[m] = sHat2[m];\n    }\n    \n    // recalculate broadband bias (max)\n    for (int i = 0; i < k; i++){\n      B(i) = (1.0 - ev[i]) * sigmasq;\n    }\n    \n    for (int i = 0; i < nfreq; i++){\n      sHat2[i] = 0.0;\n      ssd = 0.0;\n      for (int j = 0; j < k; j++){\n        d(i, j) = sqrt(ev[j]) * sHat[i] / (ev[j] * sHat[i] + B[j]); // calculate weight at freq i, taper j\n        ssd += d(i, j); // sum of square weights (d)\n        sHat2[i] += pow(std::abs(d(i, j)), 2.0) * eigenSpec(i, j); // numerator of adaptive weight formula (5.3 in '82)\n      }\n      sHat2[i] = sHat2[i] / ssd;\n    }\n   \n   sigmasq = 2.0 * sum(sHat2) / nFFT;\n }\n  \n  return d;\n}\n\n// [[Rcpp::export]]\ndouble absCplx(Rcomplex x){\n  double y = sqrt(pow(x.r, 2.0) + pow(x.i, 2.0));\n  return(y);\n}\n\n// [[Rcpp::export]]\nComplexMatrix coherencyOffsetCpp(ComplexMatrix ykx, ComplexMatrix yky\n                                   , ComplexMatrix dx, ComplexMatrix dy\n                                   , int nTaper, int nFreqRange, int nOffset\n                                   , IntegerVector range2Start, IntegerVector freqRangeIdx\n                                   , bool forwardCoh) {\n  ComplexMatrix coh(nOffset, nFreqRange);\n  Rcomplex Sx, Sy, numerator, denom, ssdx, ssdy, ssdxy, zero, dxdy;\n  zero.r = 0.0;\n  zero.i = 0.0;\n\n  std::fill(coh.begin(), coh.end(), zero); // fill coh with 0's (complex)\n  \n  for(int os = 0; os < nOffset; os++){ // 0 to 1180\n    // Rcout << \"Offset: \" << os << \"\\n\"; // for testing purposes\n    for (int f = 0; f < nFreqRange; f++){ // 0 to 1179\n      numerator = zero;\n      denom = zero;\n      ssdx = zero;\n      ssdy = zero;\n      ssdxy = zero;\n      Sx = zero;\n      Sy = zero;\n      \n      for (int k = 0; k < nTaper; k++){\n        if (forwardCoh){\n          numerator = numerator + (dx(freqRangeIdx[f], k) * dy(range2Start[os]+f, k)) * (ykx(freqRangeIdx[f], k) * internal::complex__Conj(yky(range2Start[os]+f, k)));\n        }\n        else\n        {\n          numerator = numerator + (dx(freqRangeIdx[f], k) * dy(range2Start[os]+f, k)) * (ykx(freqRangeIdx[f], k) * yky(range2Start[os]+f, k));\n        }\n        ssdxy = ssdxy + dx(freqRangeIdx[f], k) * dy(range2Start[os]+f, k);\n        Sx.r += pow(absCplx(dx(freqRangeIdx[f], k) * ykx(freqRangeIdx[f], k)), 2.0);\n        Sy.r += pow(absCplx(dy(range2Start[os]+f, k)*yky(range2Start[os]+f, k)), 2.0);\n        // Don't need this I don't think - replaced with Sx and Sy and denom below\n        //denom.r += pow(absCplx(dx(freqRangeIdx[f], k) * ykx(freqRangeIdx[f], k)), 2.0) * pow(absCplx(dy(range2Start[os]+f, k)*yky(range2Start[os]+f, k)), 2.0);\n        // Don't need these below ... I don't think, see DJT '82 - p. 1089\n        // ssdx.r += pow(dx(freqRangeIdx[f], k).r, 2.0);\n        // ssdy.r += pow(dy(range2Start[os]+f, k).r, 2.0);\n      }\n      // denom.r = sqrt( (Sx.r / ssdx.r) * (Sy.r / ssdy.r) );\n      denom.r = sqrt( (Sx.r) * (Sy.r) );\n      // don't need the normalizing factors? See DJT '82 - p. 1089\n      // coh(os, f) = (numerator / ssdxy) / denom;\n      coh(os, f) = (numerator) / denom;\n    }\n  }\n\n  return(coh);\n}",
    "created" : 1486954424517.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2138368265",
    "id" : "E7DBDFF",
    "lastKnownWriteTime" : 1486955110,
    "last_content_update" : 1486955110468,
    "path" : "~/school_lab/bin/transfer/src/coherenceCpp.cpp",
    "project_path" : "src/coherenceCpp.cpp",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}